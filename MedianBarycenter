#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

#include "nonna.h"

static int C, G, M;

struct Centrino 
{
    int id;
    vector<int> gomitoli;
    float barycenter;
};

int partitionCentrini(vector<Centrino>& arr, int low, int high) 
{
    int pivot = arr[high].median;
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (arr[j].median <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSortCentrini(vector<Centrino>& arr, int low, int high) 
{
    if (low < high) {
        int pi = partitionCentrini(arr, low, high);
        quickSortCentrini(arr, low, pi - 1);
        quickSortCentrini(arr, pi + 1, high);
    }
}

class FenwickTree {
    public:
        FenwickTree(int size): size(size) 
        {
            tree.resize(size + 1, 0);
        }

        void update(int idx, int delta)
        {
            while (idx <= size) {
                tree[idx] += delta;
                idx += idx & -idx;
            }            
        }

        int query(int idx)
        {
            int sum = 0;
            while (idx > 0) {
                sum += tree[idx];
                idx -= idx & -idx;
            }
            return sum;
        }

        int rangeQuery(int l, int r)
        {
            return query(r) - query(l );
        }

        void print()
        {
            for (int i = 1; i <= size; ++i) {
                cout << tree[i] << " ";
            }
            cout << endl;
        }

    private:
        int size;
        vector<int> tree;
};

void setBarycenter(vector<Centrino>& centrini)
{
    float sum = 0;
    for (int i = 0; i < centrini.size(); i++) {
        sum = 0;
        if (centrini[i].gomitoli.size() != 0) {
            for (int j = 0; j < centrini[i].gomitoli.size(); j++)
            {
                sum += centrini[i].gomitoli[j];
            }
            centrini[i].barycenter = sum / centrini[i].gomitoli.size();
        }
        else {
            centrini[i].barycenter = 0;
        }
        
        std::cout << "Centrino " << centrini[i].id << " barycenter: " << centrini[i].barycenter << std::endl;
    }
}

void orderByBarycenter (vector<Centrino>& centrini)
{
    setBarycenter(centrini);
    sort(centrini.begin(), centrini.end(), [](const Centrino& a, const Centrino& b) {
        return a.barycenter < b.barycenter;
    });
}

/**
 * Read input from file
 * @param path: path to the input file
 * @param centrini: vector of centrini
 * 
 * @note read the input file, insert in centrini and gomitoli
*/
void readInput(const char path[], vector<Centrino>& centrini, vector<Centrino>& tmpB, vector<Centrino>& tmpM)
{
    fstream in(path, fstream::in);
    in >> C >> G >> M;
    centrini.resize(C);
    tmpB.resize(C);
    tmpM.resize(C);

    for (int i = 0; i < C; i++)
    {
        centrini[i].id = i;
        tmpB[i].id = i;
        tmpM[i].id =i;

    }
    
    for (int i = 0; i < M; ++i) {
        int c, g;
        in >> c >> g;

        auto& gomitoli = centrini[c].gomitoli;
        auto pos = lower_bound(gomitoli.begin(), gomitoli.end(), g);
        gomitoli.insert(pos, g);

        auto& gomitoliTmpB = tmpB[c].gomitoli;
        auto posTmpB = lower_bound(gomitoliTmpB.begin(), gomitoliTmpB.end(), g);
        gomitoliTmpB.insert(posTmpB, g);

        auto& gomitoliTmpM = tmpM[c].gomitoli;
        auto posTmpM = lower_bound(gomitoliTmpM.begin(), gomitoliTmpM.end(), g);
        gomitoliTmpM.insert(posTmpM, g);
    }
    in.close();
}

int calcolaIncroci(const vector<Centrino>& centrini)
{
    int incroci = 0;
    FenwickTree tree(G);
    for (int i = 0; i < C; ++i) {
        for (int j = 0; j < centrini[i].gomitoli.size(); ++j) {
            incroci += tree.rangeQuery(centrini[i].gomitoli[j] - C + 1, G);
            tree.update(centrini[i].gomitoli[j]- C + 1, 1);
        }
    }
    return incroci;
}

void writeOutput(int incroci, const std::vector<Centrino>& centrini)
{
    std::fstream out("output.txt", std::fstream::out);
    if (!out) {
        std::cerr << "Error opening file for writing." << std::endl;
        return;
    }

    out << incroci << std::endl;
    for (int i = 0; i < centrini.size(); i++) {
        out << centrini[i].id << " ";
    }
    out << std::endl << "***";
    out.close();
}

int main()
{
    // helpers::setup(); //delete: setup the timer and timeout

    int tmpIncrociBarycenter=0, incroci=0, tmpIncrociMedian=0;
    vector<Centrino> centrini;
    vector<Centrino> tmpB;
    vector<Centrino> tmpM;
    // char path[] = "input/input0.txt";
    char path[] = "input.txt";

    readInput(path, centrini, tmpB, tmpM);
    
    orderByBarycenter(tmpB);
    quickSortCentrini(tmpM,  0, tmpM.size() - 1);

    tmpIncrociBarycenter =  calcolaIncroci(tmpB);
    tmpIncrociMedian = calcolaIncroci(tmpM);
    incroci = calcolaIncroci(centrini);

    if (tmpIncrociBarycenter>tmpIncrociMedian) {
        if(tmpIncrociMedian>incroci){
            writeOutput(incroci, centrini);
        }
        else{
            writeOutput(tmpIncrociMedian, tmpM);

        }
    }
    else{
        if(tmpIncrociBarycenter>incroci){
            writeOutput(incroci, centrini);

        }
        else{
            writeOutput(tmpIncrociBarycenter, tmpB);

        }

    }
        
       

    // std::cout << "C: " << C << " G: " << G << " M: " << M << std::endl;
    // std::cout << "Incroci: " << incroci << std::endl;
    
    return 0;
}

